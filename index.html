<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Cyber Squid - Gravity Sound Edition</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

  <style>
    body { margin: 0; padding: 0; background: #000; overflow: hidden; touch-action: none; font-family: 'Courier New', monospace; }
    
    #overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to bottom, #051020, #000);
      display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 999;
      color: #0ff; text-align: center;
    }
    
    button {
      padding: 15px 40px; font-size: 20px; color: #0ff;
      background: rgba(0, 255, 255, 0.1); border: 2px solid #0ff; border-radius: 5px;
      cursor: pointer; margin-top: 30px; letter-spacing: 2px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
      transition: all 0.2s;
    }
    button:active { background: #0ff; color: #000; }
    
    #status-bar {
      position: absolute; top: 10px; right: 10px; color: rgba(0,255,255,0.5);
      font-size: 12px; pointer-events: none;
    }
  </style>
</head>
<body>

  <div id="status-bar">Audio: Split Logic (Jump/Fall)</div>

  <div id="overlay">
    <h1 style="text-shadow: 0 0 20px #0ff; font-size: 40px; margin-bottom: 0;">CYBER SQUID</h1>
    <p style="color: #0aa; font-size: 14px;">GRAVITY RESONANCE SYSTEM</p>
    <button id="start-btn">INITIALIZE</button>
    <p style="font-size: 12px; margin-top: 20px; opacity: 0.6;">Tap to Jump • Listen to Gravity</p>
  </div>

<script>
// ==========================================
//  PART 1: 雙重聲音系統 (Jump vs Fall)
// ==========================================
let jumpSynth;   // 負責跳躍的純音
let fallSynth;   // 負責掉落的彈跳聲
let isAudioReady = false;

// 掉落聲音的計時器 ID (用來在跳躍時取消掉落聲)
let fallTimeoutID = null;
let isFallingSoundPlaying = false;

async function initAudio() {
    await Tone.start();
    
    // 1. 跳躍合成器 (乾淨的純音)
    jumpSynth = new Tone.Synth({
        oscillator: { type: "triangle" }, // 三角波比較溫潤，不像正弦波那麼單薄
        envelope: {
            attack: 0.005,
            decay: 0.3,
            sustain: 0,
            release: 0.1
        }
    }).toDestination();
    jumpSynth.volume.value = -8;

    // 2. 掉落合成器 (彈跳球效果，稍微短促一點)
    fallSynth = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: {
            attack: 0.005,
            decay: 0.1,
            sustain: 0,
            release: 0.1
        }
    }).toDestination();
    fallSynth.volume.value = -10;

    isAudioReady = true;
    document.getElementById('overlay').style.display = 'none';
    startGame();
}

// --- A. 跳躍聲音 (Pure Tone) ---
function playJumpSound(power) {
    if (!isAudioReady) return;
    
    // ★ 如果正在播放掉落聲，立刻切斷它！(因為玩家重新獲得動力了) ★
    stopFallingSequence();

    // 根據力道 (0.0 ~ 1.0) 決定音高
    // 力道越大，音越高 (400Hz ~ 800Hz)
    let pitch = map(power, 0.0, 1.0, 400, 800);
    
    jumpSynth.triggerAttackRelease(pitch, "8n");
}

// --- B. 掉落聲音 (Bouncing Ball Effect) ---
function startFallingSequence() {
    if (!isAudioReady || isFallingSoundPlaying) return;
    
    isFallingSoundPlaying = true;
    
    // 參數設定
    let currentPitch = 1000; // 從高頻開始掉
    let currentGap = 0.15;   // 初始間隔 (秒)
    let currentVol = -5;     // 初始音量 (dB)
    
    // 定義遞迴函數
    function playBeat() {
        if (!isFallingSoundPlaying) return; // 被中斷就停止

        let now = Tone.now();
        
        // 播放一個短音
        fallSynth.triggerAttackRelease(currentPitch, currentGap * 0.8, now, Tone.dbToGain(currentVol));

        // 計算下一次的變化 (物理衰減模擬)
        currentPitch *= 0.85; // 音高降低
        currentGap *= 0.8;    // 速度變快 (間隔變短)
        currentVol -= 2;      // 音量變小
        
        // 停止條件：頻率太低 或 間隔太密
        if (currentPitch > 100 && currentGap > 0.02) {
            // 預排下一次聲音
            // 注意：這裡我們用 setTimeout 配合 Tone.now 來實現簡單排程
            // 因為要能在外部中斷，我們把 ID 存起來
            fallTimeoutID = setTimeout(playBeat, currentGap * 1000);
        } else {
            isFallingSoundPlaying = false;
        }
    }
    
    // 啟動序列
    playBeat();
}

function stopFallingSequence() {
    isFallingSoundPlaying = false;
    if (fallTimeoutID) {
        clearTimeout(fallTimeoutID);
        fallTimeoutID = null;
    }
}


// ==========================================
//  PART 2: p5.js 遊戲邏輯
// ==========================================
let squid;
let bubbles = [];
let gameState = 0; // 0:Menu, 1:Play, 2:Over
let score = 0;

function setup() {
    createCanvas(windowWidth, windowHeight);
    squid = new TechSquid(width/2, height/2);
    for(let i=0; i<30; i++) bubbles.push(new Bubble());
    
    document.getElementById('start-btn').addEventListener('click', initAudio);
    noLoop();
}

function startGame() {
    gameState = 1;
    score = 0;
    squid.reset(width/2, height/2);
    loop();
}

function draw() {
    drawBackground();

    // 背景氣泡
    for (let b of bubbles) {
        b.update();
        b.display();
    }

    if (gameState === 1) {
        squid.update();
        squid.display();
        
        // ★ 核心邏輯：偵測掉落 ★
        // 如果速度向下 (vel.y > 0) 且 還沒播放掉落聲 -> 觸發
        // 加一個 threshold (1.0) 避免在頂點輕微晃動時一直觸發
        if (squid.vel.y > 1.5 && !isFallingSoundPlaying) {
            startFallingSequence();
        }

        // 邊界檢查
        if (squid.pos.y > height + 60 || squid.pos.y < -60) {
            gameOver();
        }
        
        // 分數
        score += 0.05;
        fill(255); textSize(16); textAlign(LEFT, TOP);
        text("DEPTH: " + floor(score) + "m", 20, 20);
        
    } else if (gameState === 2) {
        squid.display();
        fill(255, 50, 50); textSize(50); textAlign(CENTER, CENTER);
        text("SIGNAL LOST", width/2, height/2);
        textSize(16); fill(255);
        text("Tap to Reboot System", width/2, height/2 + 50);
    }
}

function gameOver() {
    gameState = 2;
    stopFallingSequence(); // 遊戲結束停止掉落聲
    
    if(isAudioReady) {
        // Game Over 音效
        const osc = new Tone.Oscillator(100, "sawtooth").toDestination().start();
        osc.frequency.rampTo(20, 1);
        osc.stop("+1");
    }
}

function mousePressed() {
    if (!isAudioReady) return;

    if (gameState === 1) {
        // ★ 點擊時：只觸發跳躍 ★
        let power = random(0.6, 0.9); // 模擬力度
        squid.jump(power);
        playJumpSound(power); // 播放純音 (並切斷掉落聲)
    } else if (gameState === 2) {
        startGame();
    }
    return false; // 防止手機雙擊縮放
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    squid.pos.x = width/2;
}

function drawBackground() {
    let ctx = drawingContext;
    let gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, "#050f1e");
    gradient.addColorStop(1, "#000000");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
}

// ==========================================
//  PART 3: 章魚與氣泡類別 (Cyber Squid Visuals)
// ==========================================
class TechSquid {
    constructor(x, y) {
        this.reset(x, y);
        this.size = 60;
        this.baseColor = color(0, 255, 255);
    }
    
    reset(x, y) {
        this.pos = createVector(x, y);
        this.vel = createVector(0, 0);
        this.gravity = 0.35; // 稍微調輕一點，讓掉落感更明顯
        this.drag = 0.96;
        this.bodyColor = this.baseColor;
        this.squish = 1.0;
        this.tentaclePhase = 0;
        this.eyeSize = 15;
    }
    
    jump(power) {
        this.vel.y = -10 - (power * 3);
        this.squish = 0.6;
        this.bodyColor = color(255, 50, 255); // 跳躍變紫
        this.eyeSize = 25;
        
        // 粒子
        for(let i=0; i<8; i++) bubbles.push(new Bubble(this.pos.x, this.pos.y + 30, true));
    }
    
    update() {
        this.vel.y += this.gravity;
        this.vel.mult(this.drag);
        this.pos.add(this.vel);
        this.pos.x = constrain(this.pos.x, 30, width-30);
        
        // 動畫
        this.squish = lerp(this.squish, 1.0 + sin(frameCount*0.1)*0.05, 0.1);
        this.bodyColor = lerpColor(this.bodyColor, this.baseColor, 0.05);
        this.eyeSize = lerp(this.eyeSize, 15, 0.1);
        this.tentaclePhase += 0.1 + abs(this.vel.y)*0.05;
    }
    
    display() {
        push();
        translate(this.pos.x, this.pos.y);
        rotate(this.vel.y * 0.02);
        
        // 觸手 (Neon Glow)
        noFill(); strokeWeight(4);
        for(let i=-2; i<=2; i++) {
            stroke(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 200);
            beginShape();
            for(let j=0; j<10; j++) {
                let wave = sin(this.tentaclePhase + i + j*0.5) * j*2;
                vertex(i*10 + wave - this.vel.x*j*0.5, 30 + j*8);
            }
            endShape();
        }
        
        // 身體
        scale(1, this.squish);
        noStroke(); fill(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 150);
        arc(0, 0, this.size*2, this.size*1.8, PI, TWO_PI);
        rect(-this.size, 0, this.size*2, 10);
        
        // 外框
        noFill(); stroke(this.bodyColor); strokeWeight(2);
        arc(0, 0, this.size*1.8, this.size*1.6, PI, TWO_PI);
        
        // 眼睛
        let eyeY = -10;
        fill(255); noStroke();
        ellipse(-20, eyeY, this.eyeSize+5); ellipse(20, eyeY, this.eyeSize+5);
        fill(0); // 眼珠
        ellipse(-20 + this.vel.x*0.5, eyeY + this.vel.y*0.2, 5);
        ellipse(20 + this.vel.x*0.5, eyeY + this.vel.y*0.2, 5);
        
        pop();
    }
}

class Bubble {
    constructor(x, y, burst) {
        this.isBurst = burst;
        if(burst) {
            this.pos = createVector(x, y);
            this.size = random(5, 15);
            this.speed = random(3, 8);
            this.alpha = 255;
        } else {
            this.reset();
        }
    }
    reset() {
        this.pos = createVector(random(width), random(height));
        this.size = random(2, 6);
        this.speed = random(0.5, 2);
        this.alpha = random(50, 150);
        this.isBurst = false;
    }
    update() {
        this.pos.y -= this.speed;
        if(this.isBurst) {
            this.size *= 0.9;
            this.alpha -= 10;
            if(this.alpha < 0) this.pos.y = -100;
        } else {
            if(this.pos.y < -10) this.reset();
        }
    }
    display() {
        if(this.alpha <= 0) return;
        noStroke(); fill(200, 255, 255, this.alpha);
        ellipse(this.pos.x, this.pos.y, this.size);
    }
}
</script>
</body>
</html>
