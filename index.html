<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Cyber Squid - Cave Dive</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

  <style>
    body { margin: 0; padding: 0; background: #000; overflow: hidden; touch-action: none; font-family: 'Courier New', monospace; }
    
    #overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to bottom, #051020, #000);
      display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 999;
      color: #0ff; text-align: center;
    }
    
    button {
      padding: 15px 40px; font-size: 20px; color: #0ff;
      background: rgba(0, 255, 255, 0.1); border: 2px solid #0ff; border-radius: 5px;
      cursor: pointer; margin-top: 30px; letter-spacing: 2px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
    }
    
    #hud {
      position: absolute; top: 20px; left: 20px; color: #0ff;
      font-size: 18px; pointer-events: none; text-shadow: 0 0 5px #0ff;
      display: none;
    }
  </style>
</head>
<body>

  <div id="hud">
    SCORE: <span id="score-val">0</span> <br>
    TIME: <span id="time-val">0</span>s
  </div>

  <div id="overlay">
    <h1 style="text-shadow: 0 0 20px #0ff; font-size: 40px; margin-bottom: 0;">CYBER SQUID</h1>
    <p style="color: #0aa; font-size: 14px;">CAVE EXPLORATION MODE</p>
    <button id="start-btn">START DIVE</button>
  </div>

<script>
// ==========================================
//  PART 1: 聲音系統 (新增寶物音效)
// ==========================================
let jumpSynth, fallSynth, collectSynth, crashSynth;
let isAudioReady = false;
let lastJumpPitch = 600;
let fallTimeoutID = null;
let isFallingSoundPlaying = false;

async function initAudio() {
    await Tone.start();
    
    // 1. 跳躍 (動力) - Sine Wave
    jumpSynth = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: { attack: 0.02, decay: 0.3, sustain: 0, release: 0.5 }
    }).toDestination();
    jumpSynth.volume.value = -2;

    // 2. 掉落 (彈跳感)
    fallSynth = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }
    }).toDestination();
    fallSynth.volume.value = -5;

    // 3. ★ 新增：吃到寶物 (清脆的高頻) ★
    collectSynth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "triangle" },
        envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }
    }).toDestination();
    collectSynth.volume.value = -8;

    // 4. ★ 新增：撞擊/死亡 (噪音) ★
    crashSynth = new Tone.NoiseSynth({
        noise: { type: "pink" },
        envelope: { attack: 0.005, decay: 0.5, sustain: 0 }
    }).toDestination();

    isAudioReady = true;
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    startGame();
}

function playJumpSound(power) {
    if (!isAudioReady) return;
    stopFallingSequence();
    let pitch = map(power, 0.0, 1.0, 300, 700);
    lastJumpPitch = pitch;
    jumpSynth.triggerAttackRelease(pitch, "8n");
}

function playCollectSound() {
    if (!isAudioReady) return;
    // 隨機雙音，增加悅耳感
    collectSynth.triggerAttackRelease(["C6", "E6"], "16n");
}

function playCrashSound() {
    if (!isAudioReady) return;
    crashSynth.triggerAttackRelease("8n");
}

function startFallingSequence() {
    if (!isAudioReady || isFallingSoundPlaying) return;
    isFallingSoundPlaying = true;
    let currentPitch = lastJumpPitch;
    let currentGap = 0.15;
    let currentVol = -5;
    
    function playBeat() {
        if (!isFallingSoundPlaying) return;
        let now = Tone.now();
        fallSynth.triggerAttackRelease(currentPitch, currentGap * 0.8, now, Tone.dbToGain(currentVol));
        currentPitch *= 0.85;
        currentGap *= 0.8;
        currentVol -= 2;
        if (currentPitch > 50 && currentGap > 0.02) {
            fallTimeoutID = setTimeout(playBeat, currentGap * 1000);
        } else {
            isFallingSoundPlaying = false;
        }
    }
    playBeat();
}

function stopFallingSequence() {
    isFallingSoundPlaying = false;
    if (fallTimeoutID) { clearTimeout(fallTimeoutID); fallTimeoutID = null; }
}

// ==========================================
//  PART 2: 遊戲邏輯 (卷軸式)
// ==========================================
let squid;
let particles = [];
let terrain; // 洞穴地形
let pearls = []; // 寶物
let gameState = 0;
let score = 0;
let survivalTime = 0;
let gameSpeed = 5; // 卷動速度

function setup() {
    createCanvas(windowWidth, windowHeight);
    squid = new TechSquid(width * 0.2, height/2); // 固定在左側 20% 處
    terrain = new CaveTerrain();
    
    document.getElementById('start-btn').addEventListener('click', initAudio);
    noLoop();
}

function startGame() {
    gameState = 1;
    score = 0;
    survivalTime = 0;
    gameSpeed = 5;
    squid.reset(width * 0.2, height/2);
    terrain.reset();
    pearls = [];
    loop();
}

function draw() {
    drawBackground();

    if (gameState === 1) {
        // --- 更新邏輯 ---
        gameSpeed += 0.001; // 隨時間稍微變快
        survivalTime += 0.016; // 約 60fps
        
        // 1. 地形更新
        terrain.update();
        terrain.display();

        // 2. 寶物生成與更新
        if (frameCount % 60 === 0 && random() > 0.3) {
            pearls.push(new Pearl(width, terrain.getCenterY(width)));
        }
        for (let i = pearls.length - 1; i >= 0; i--) {
            let p = pearls[i];
            p.update();
            p.display();
            
            // 吃到寶物
            if (p.hits(squid)) {
                score += 50;
                playCollectSound();
                // 產生特效
                for(let k=0; k<5; k++) particles.push(new Bubble(p.pos.x, p.pos.y, true));
                pearls.splice(i, 1);
            } else if (p.offscreen()) {
                pearls.splice(i, 1);
            }
        }

        // 3. 章魚更新
        squid.update();
        squid.display();
        
        // 掉落聲音偵測
        if (squid.vel.y > 2.5 && !isFallingSoundPlaying) {
            startFallingSequence();
        }

        // 4. 碰撞判定 (Crash Logic)
        // 撞到天花板或地板
        if (terrain.checkCollision(squid)) {
            gameOver();
        }

        // UI 更新
        document.getElementById('score-val').innerText = floor(score + survivalTime * 10);
        document.getElementById('time-val').innerText = floor(survivalTime);

    } else if (gameState === 2) {
        // Game Over 畫面
        terrain.display();
        squid.display();
        fill(255, 50, 50); textSize(50); textAlign(CENTER, CENTER);
        text("HULL BREACH", width/2, height/2);
        textSize(20); fill(255);
        text("Tap to Restart Mission", width/2, height/2 + 60);
    }
    
    // 背景粒子 (永遠存在)
    if (random() > 0.8) particles.push(new Bubble(width, random(height), false));
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].display();
        if (particles[i].finished()) particles.splice(i, 1);
    }
}

function gameOver() {
    gameState = 2;
    stopFallingSequence();
    playCrashSound();
}

function mousePressed() {
    if (!isAudioReady) return;

    if (gameState === 1) {
        let power = random(0.6, 0.9);
        squid.jump(power);
        playJumpSound(power);
    } else if (gameState === 2) {
        startGame();
    }
    return false;
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    squid.reset(width * 0.2, height/2);
}

function drawBackground() {
    let ctx = drawingContext;
    let gradient = ctx.createLinearGradient(0, 0, 0, height);
    // 深海洞穴背景
    gradient.addColorStop(0, "#020510");
    gradient.addColorStop(1, "#000000");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
}

// ==========================================
//  PART 3: 類別 (章魚, 寶物, 地形)
// ==========================================

class CaveTerrain {
    constructor() {
        this.reset();
        this.noiseOffset = 0;
    }
    
    reset() {
        this.noiseOffset = 0;
        this.segments = []; // 儲存地形高度的陣列
        // 預先生成畫面寬度的地形
        for(let x=0; x<=width; x+=10) {
            this.segments.push(this.generateHeight(x));
        }
    }
    
    generateHeight(x) {
        // 使用 Perlin Noise 生成洞穴
        // top: 天花板高度 (0 ~ height/2)
        // bottom: 地板高度 (height/2 ~ height)
        let n = noise(this.noiseOffset);
        this.noiseOffset += 0.05; // 數字越小，洞穴越平滑
        
        let gapSize = map(n, 0, 1, 300, 500); // 洞穴開口大小
        let center = map(noise(this.noiseOffset * 0.5 + 100), 0, 1, 100, height-100); // 洞穴中心點上下移動
        
        return {
            x: x,
            top: center - gapSize/2,
            bottom: center + gapSize/2
        };
    }
    
    update() {
        // 移動地形 (往左卷動)
        for (let s of this.segments) {
            s.x -= gameSpeed;
        }
        
        // 移除超出左邊的
        if (this.segments[0].x < -10) {
            this.segments.shift();
        }
        
        // 在右邊新增
        let lastX = this.segments[this.segments.length-1].x;
        if (lastX < width) {
            this.segments.push(this.generateHeight(lastX + 10));
        }
    }
    
    display() {
        fill(20, 30, 40); // 岩石顏色
        stroke(0, 255, 255, 50); // 岩石邊緣微光
        
        // 畫天花板
        beginShape();
        vertex(0, 0);
        for (let s of this.segments) vertex(s.x, s.top);
        vertex(width, 0);
        endShape(CLOSE);
        
        // 畫地板
        beginShape();
        vertex(0, height);
        for (let s of this.segments) vertex(s.x, s.bottom);
        vertex(width, height);
        endShape(CLOSE);
    }
    
    // 取得某處的中心點 (給寶物生成用)
    getCenterY(atX) {
        let n = noise(this.noiseOffset);
        return map(noise(this.noiseOffset * 0.5 + 100), 0, 1, 100, height-100);
    }
    
    // 碰撞偵測
    checkCollision(squid) {
        // 找到章魚目前 X 位置對應的地形段落
        // 這裡做簡單判定：找出離章魚最近的 segment
        for (let s of this.segments) {
            if (abs(s.x - squid.pos.x) < 10) {
                // 判定：如果章魚碰到天花板或地板
                // 縮小一點判定範圍 (Hitbox) 讓遊戲簡單一點點
                let hitTop = (squid.pos.y - squid.size/2) < s.top + 10;
                let hitBot = (squid.pos.y + squid.size/2) > s.bottom - 10;
                if (hitTop || hitBot) return true;
            }
        }
        return false;
    }
}

class Pearl {
    constructor(x, y) {
        this.pos = createVector(x, y);
        this.r = 15;
    }
    update() {
        this.pos.x -= gameSpeed;
    }
    display() {
        noStroke();
        // 珍珠光暈
        fill(255, 255, 200, 100);
        ellipse(this.pos.x, this.pos.y, this.r * 2);
        // 珍珠本體
        fill(255);
        ellipse(this.pos.x, this.pos.y, this.r);
    }
    hits(squid) {
        let d = dist(this.pos.x, this.pos.y, squid.pos.x, squid.pos.y);
        return d < this.r + squid.size/2;
    }
    offscreen() {
        return this.pos.x < -50;
    }
}

class TechSquid {
    constructor(x, y) {
        this.reset(x, y);
        this.size = 50; // 稍微縮小一點以利鑽洞
        this.baseColor = color(0, 255, 255);
    }
    
    reset(x, y) {
        this.pos = createVector(x, y);
        this.vel = createVector(0, 0);
        this.gravity = 0.4;
        this.drag = 0.95;
        this.bodyColor = this.baseColor;
        this.squish = 1.0;
        this.tentaclePhase = 0;
        this.eyeSize = 15;
    }
    
    jump(power) {
        this.vel.y = -8 - (power * 3);
        this.squish = 0.6;
        this.bodyColor = color(255, 50, 255);
        this.eyeSize = 25;
        for(let i=0; i<5; i++) particles.push(new Bubble(this.pos.x, this.pos.y + 20, true));
    }
    
    update() {
        this.vel.y += this.gravity;
        this.vel.mult(this.drag);
        this.pos.add(this.vel);
        
        // 這裡不限制 pos.y，因為超出畫面撞牆交給 terrain 處理
        
        this.squish = lerp(this.squish, 1.0 + sin(frameCount*0.1)*0.05, 0.1);
        this.bodyColor = lerpColor(this.bodyColor, this.baseColor, 0.05);
        this.eyeSize = lerp(this.eyeSize, 15, 0.1);
        this.tentaclePhase += 0.2; // 觸手動快一點
    }
    
    display() {
        push();
        translate(this.pos.x, this.pos.y);
        // 根據速度旋轉，模擬前進感
        let angle = map(this.vel.y, -10, 10, -PI/6, PI/6);
        rotate(angle);
        
        // 觸手 (向後飄)
        noFill(); strokeWeight(3);
        for(let i=-2; i<=2; i++) {
            stroke(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 200);
            beginShape();
            for(let j=0; j<8; j++) {
                // 讓觸手水平向後飄
                let wave = sin(this.tentaclePhase + i + j*0.5) * 5;
                vertex(-15 - j*8, i*8 + wave);
            }
            endShape();
        }
        
        // 身體 (橫向)
        scale(this.squish, 1); // 橫向擠壓
        noStroke(); fill(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 150);
        ellipse(0, 0, this.size*1.5, this.size);
        
        // 眼睛
        fill(255);
        ellipse(10, -5, this.eyeSize);
        fill(0);
        ellipse(10 + 2, -5, 5);
        
        pop();
    }
}

class Bubble {
    constructor(x, y, burst) {
        this.pos = createVector(x, y);
        this.isBurst = burst;
        if(burst) {
            this.vel = p5.Vector.random2D().mult(random(2, 5));
            this.size = random(5, 10);
            this.alpha = 255;
        } else {
            this.vel = createVector(-gameSpeed * random(0.5, 1.5), random(-1, 1));
            this.size = random(2, 5);
            this.alpha = random(50, 150);
        }
    }
    update() {
        this.pos.add(this.vel);
        if(this.isBurst) {
            this.size *= 0.9;
            this.alpha -= 10;
        }
    }
    display() {
        if(this.alpha <= 0) return;
        noStroke(); fill(200, 255, 255, this.alpha);
        ellipse(this.pos.x, this.pos.y, this.size);
    }
    finished() {
        return this.alpha < 0 || this.pos.x < 0;
    }
}
</script>
</body>
</html>
