<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Cyber Squid - Evolution</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

  <style>
    body { margin: 0; padding: 0; background: #000; overflow: hidden; touch-action: none; font-family: 'Courier New', monospace; }
    
    #overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to bottom, #051020, #000);
      display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 999;
      color: #0ff; text-align: center;
    }
    
    button {
      padding: 20px 60px; font-size: 24px; color: #0ff;
      background: rgba(0, 255, 255, 0.1); border: 3px solid #0ff; border-radius: 50px;
      cursor: pointer; margin-top: 30px; letter-spacing: 2px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
    }
    
    #hud {
      position: absolute; top: 20px; left: 20px; color: #0ff;
      font-size: 24px; pointer-events: none; text-shadow: 0 0 5px #0ff;
      display: none; font-weight: bold;
    }
    
    #hp-bar {
        position: absolute; top: 20px; right: 20px;
        font-size: 30px; color: #ff5555; text-shadow: 0 0 5px #f00;
        display: none;
        text-align: right;
    }

    .combo-text {
        position: absolute;
        color: #ffff00;
        font-weight: bold;
        font-size: 24px;
        pointer-events: none;
        animation: floatUp 1s forwards;
        text-shadow: 0 0 10px #ffaa00;
        z-index: 10;
    }
    
    .jackpot-text {
        position: absolute;
        color: #FFD700;
        font-weight: bold;
        font-size: 50px;
        pointer-events: none;
        animation: zoomOut 2s forwards;
        text-shadow: 0 0 30px #ffffff;
        z-index: 20;
        width: 100%;
        text-align: center;
        top: 35%;
    }
    
    @keyframes floatUp {
        0% { transform: translateY(0) scale(1); opacity: 1; }
        50% { transform: translateY(-30px) scale(1.5); opacity: 1; }
        100% { transform: translateY(-60px) scale(1); opacity: 0; }
    }
    
    @keyframes zoomOut {
        0% { transform: scale(0.5); opacity: 0; }
        50% { transform: scale(1.2); opacity: 1; }
        100% { transform: scale(2.0); opacity: 0; }
    }
  </style>
</head>
<body>

  <div id="hud">SCORE: <span id="score-val">0</span></div>
  <div id="hp-bar">â¤â¤â¤</div>

  <div id="overlay">
    <h1 style="text-shadow: 0 0 20px #0ff; font-size: 50px; margin-bottom: 0;">æ·±æµ·çƒè³Š</h1>
    <p style="color: #0aa; font-size: 20px;">ç„¡é™é€²åŒ– â€¢ æ™ºæ…§ Combo</p>
    <button id="start-btn">é–‹å§‹å†’éšª</button>
  </div>

<script>
// ==========================================
//  PART 1: è²éŸ³ç³»çµ±
// ==========================================
let jumpSynth, fallSynth, collectSynth, collisionSynth, jackpotSynth, dieSynth;
let isAudioReady = false;
let lastJumpPitch = 600;
let fallTimeoutID = null;
let isFallingSoundPlaying = false;

const noteMap = [
    "C5", "D5", "E5", "G5", "A5",
    "C6", "D6", "E6", "G6", "A6",
    "C7", "E7", "G7"
];

async function initAudio() {
    await Tone.start();
    
    jumpSynth = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: { attack: 0.02, decay: 0.3, sustain: 0, release: 0.5 }
    }).toDestination();
    jumpSynth.volume.value = -2;

    fallSynth = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }
    }).toDestination();
    fallSynth.volume.value = -5;

    // æ”¶é›†è² (PolySynth Triangle)
    collectSynth = new Tone.PolySynth(Tone.Synth, {
        maxPolyphony: 32,
        oscillator: { type: "triangle" },
        envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.5 }
    }).toDestination();
    collectSynth.volume.value = -5;
    
    // éé—œè² (ç¥è–å’Œå¼¦)
    jackpotSynth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "triangle" },
        envelope: { attack: 0.1, decay: 1.0, sustain: 0.5, release: 3.0 }
    }).toDestination();
    jackpotSynth.volume.value = -8;

    collisionSynth = new Tone.FMSynth({
        harmonicity: 3.0, modulationIndex: 10, oscillator: { type: "sine" }, modulation: { type: "square" },
        envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.3 },
        modulationEnvelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.3 }
    }).toDestination();
    collisionSynth.volume.value = -2;
    
    dieSynth = new Tone.NoiseSynth({
        noise: { type: "brown" },
        envelope: { attack: 0.01, decay: 0.5, sustain: 0 }
    }).toDestination();
    dieSynth.volume.value = -2;

    isAudioReady = true;
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    document.getElementById('hp-bar').style.display = 'block';
    startGame();
}

function playJumpSound(power) {
    if (!isAudioReady) return;
    stopFallingSequence();
    let pitch = map(power, 0.0, 1.0, 300, 700);
    lastJumpPitch = pitch;
    
    // é«˜éšé€²åŒ–æ™‚è²éŸ³è®Šå¼·
    if (squid && squid.evolutionLevel >= 5) {
        jumpSynth.oscillator.type = "square";
        jumpSynth.volume.value = -8;
    } else {
        jumpSynth.oscillator.type = "sine";
        jumpSynth.volume.value = -2;
    }
    jumpSynth.triggerAttackRelease(pitch, "8n");
}

function playCollectSound(comboIndex) {
    if (!isAudioReady) return;
    let index = Math.min(comboIndex, noteMap.length - 3);
    let rootNote = noteMap[index];
    let harmNote = noteMap[index + 2];
    collectSynth.triggerAttackRelease([rootNote, harmNote], "16n");
}

function playJackpotSound() {
    if (!isAudioReady) return;
    // æ’­æ”¾ C å¤§èª¿ä¸ƒå’Œå¼¦ï¼Œç¥è–æ„Ÿ
    jackpotSynth.triggerAttackRelease(["C4", "G4", "C5", "E5", "G5", "B5", "C6"], "1n");
}

function playCollisionSound() {
    if (!isAudioReady) return;
    collisionSynth.triggerAttackRelease("C3", "8n");
    collisionSynth.frequency.rampTo("C2", 0.1);
}

function playDieSound() {
    if (!isAudioReady) return;
    dieSynth.triggerAttackRelease("4n");
    collisionSynth.triggerAttackRelease("C2", "2n");
    collisionSynth.frequency.rampTo("C1", 1);
}

function startFallingSequence() {
    if (!isAudioReady || isFallingSoundPlaying) return;
    isFallingSoundPlaying = true;
    let currentPitch = lastJumpPitch;
    let currentGap = 0.15;
    let currentVol = -5;
    
    if (squid && squid.evolutionLevel >= 5) {
        fallSynth.oscillator.type = "square";
        fallSynth.volume.value = -10;
    } else {
        fallSynth.oscillator.type = "sine";
        fallSynth.volume.value = -5;
    }

    function playBeat() {
        if (!isFallingSoundPlaying) return;
        let now = Tone.now();
        fallSynth.triggerAttackRelease(currentPitch, currentGap * 0.8, now, Tone.dbToGain(currentVol));
        currentPitch *= 0.85; currentGap *= 0.8; currentVol -= 2;
        if (currentPitch > 50 && currentGap > 0.02) {
            fallTimeoutID = setTimeout(playBeat, currentGap * 1000);
        } else { isFallingSoundPlaying = false; }
    }
    playBeat();
}
function stopFallingSequence() {
    isFallingSoundPlaying = false;
    if (fallTimeoutID) { clearTimeout(fallTimeoutID); fallTimeoutID = null; }
}

// ==========================================
//  PART 2: éŠæˆ²é‚è¼¯ (é€²åŒ– & æ™ºæ…§Combo)
// ==========================================
let squid;
let particles = [];
let stars = [];
let terrain;
let pearls = [];
let gameState = 0;
let score = 0;
let gameSpeed = 3;
let shakeAmount = 0;
let canRestart = false;
let flashScreen = 0; // éé—œé–ƒå…‰

let comboCount = 0;
let comboTimer = 0;
const COMBO_TIME_LIMIT = 300;
// è§¸ç™¼é€²åŒ–çš„é–€æª»ï¼šæ¯ 1 å€‹ Combo å°±é€²åŒ–ä¸€æ¬¡ï¼
// è§¸ç™¼éé—œçš„é–€æª»ï¼š8 é€£é–
const WIN_COMBO = 8;

function setup() {
    createCanvas(windowWidth, windowHeight);
    squid = new TechSquid(width * 0.25, height/2);
    terrain = new CaveTerrain();
    
    let btn = document.getElementById('start-btn');
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); initAudio(); });
    btn.addEventListener('click', initAudio);
    
    noLoop();
}

function startGame() {
    gameState = 1;
    score = 0;
    gameSpeed = 3.5;
    comboCount = 0;
    comboTimer = 0;
    flashScreen = 0;
    squid.reset(width * 0.25, height/2);
    terrain.reset(true);
    
    pearls = [];
    particles = [];
    stars = [];
    updateHPDisplay();
    loop();
}

function updateHPDisplay() {
    let hp = squid.hp;
    let hpElement = document.getElementById('hp-bar');
    let heartSymbol = "â¤";
    let color = "#ff5555";
    
    if (hp > 20) { heartSymbol = "ğŸ‘‘"; color = "#ffd700"; }
    else if (hp > 10) { heartSymbol = "ğŸ’›"; color = "#ffff00"; }
    else if (hp > 5) { heartSymbol = "ğŸ’™"; color = "#00ffff"; }

    if (hp > 15) { hpElement.innerText = heartSymbol + " x" + hp; }
    else {
        let str = ""; for(let i=0; i<hp; i++) str += heartSymbol; hpElement.innerText = str;
    }
    hpElement.style.color = color;
    hpElement.style.textShadow = `0 0 5px ${color}`;
}

function showComboText(x, y, count) {
    let el = document.createElement('div');
    el.className = 'combo-text';
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.innerText = count > 1 ? "COMBO x" + count + "!" : "NICE!";
    if(count > 5) el.style.color = "#ff00ff";
    document.body.appendChild(el);
    setTimeout(() => { document.body.removeChild(el); }, 1000);
}

function showJackpotText() {
    let el = document.createElement('div');
    el.className = 'jackpot-text';
    el.innerHTML = "STAGE CLEARED!<br>ULTIMATE EVOLUTION!";
    document.body.appendChild(el);
    setTimeout(() => { document.body.removeChild(el); }, 2500);
}

function draw() {
    push();
    if (shakeAmount > 0) {
        translate(random(-shakeAmount, shakeAmount), random(-shakeAmount, shakeAmount));
        shakeAmount *= 0.9;
        if(shakeAmount < 0.5) shakeAmount = 0;
    }
    
    drawBackground();

    if (gameState === 1) {
        gameSpeed += 0.0002;
        
        // â˜… æ™ºæ…§ Combo é‚è¼¯ï¼šæª¢æŸ¥è¢å¹•ä¸Šæ˜¯å¦æœ‰çç  â˜…
        let hasPearlOnScreen = pearls.some(p => p.pos.x > 0 && p.pos.x < width);
        
        if (comboCount > 0) {
            // åªæœ‰ç•¶è¢å¹•ä¸Šæœ‰çç æ™‚ï¼Œæ‰é–‹å§‹å€’æ•¸ (å…¬å¹³æ©Ÿåˆ¶)
            if (hasPearlOnScreen) {
                comboTimer--;
            }
            
            let barWidth = map(comboTimer, 0, COMBO_TIME_LIMIT, 0, 200);
            noStroke();
            // å¦‚æœæš«åœè¨ˆæ™‚ï¼Œè®Šç™½è‰²æç¤º
            if (hasPearlOnScreen) fill(255, 255, 0, 150);
            else fill(255, 255, 255, 100);
            
            rect(width/2 - 100, 80, barWidth, 10, 5);
            
            if (comboTimer <= 0) {
                comboCount = 0; // çœŸçš„æ²’åƒåˆ°ï¼Œæ–·é€£
                squid.setEvolution(0); // é€€åŒ–å›åŸå‹
            }
        }
        
        terrain.update();
        terrain.display();

        if (frameCount % 80 === 0 && random() > 0.2) {
            pearls.push(new Pearl(width, terrain.getCenterY(width)));
        }
        for (let i = pearls.length - 1; i >= 0; i--) {
            let p = pearls[i];
            p.update();
            p.display();
            
            if (p.hits(squid)) {
                comboCount++;
                comboTimer = COMBO_TIME_LIMIT;
                score += 100 + (comboCount * 50);
                
                // â˜… é€²åŒ–é‚è¼¯ï¼šCombo å¹¾å°±é€²åŒ–æˆå¹¾è™Ÿç”Ÿç‰© â˜…
                squid.setEvolution(comboCount);

                // â˜… éé—œåˆ¤å®š (Combo 8) â˜…
                if (comboCount >= WIN_COMBO) {
                    playJackpotSound();
                    score += 5000;
                    squid.hp = max(squid.hp + 1, 5); // è£œæ»¿è‡³å°‘5æ»´è¡€
                    updateHPDisplay();
                    
                    showJackpotText();
                    flashScreen = 255; // é–ƒå…‰ç‰¹æ•ˆ
                    
                    for(let k=0; k<50; k++) stars.push(new StarParticle(p.pos.x, p.pos.y));
                    
                    // éé—œå¾Œ Combo æ­¸é›¶ï¼Œé–‹å§‹æ–°è¼ªè¿´
                    comboCount = 0;
                    squid.setEvolution(0);
                } else {
                    playCollectSound(comboCount - 1);
                    showComboText(screenPosition(p.pos.x), screenPosition(p.pos.y), comboCount);
                    for(let k=0; k<8; k++) particles.push(new Bubble(p.pos.x, p.pos.y, true));
                }
                pearls.splice(i, 1);
            } else if (p.offscreen()) {
                pearls.splice(i, 1);
            }
        }

        squid.update();
        squid.display();
        
        if (squid.vel.y > 2.5 && !isFallingSoundPlaying) {
            startFallingSequence();
        }

        let collision = terrain.checkCollision(squid);
        if (collision.hit) {
            if (collision.type === 'top') {
                squid.pos.y = collision.limit + squid.size/2 + 2;
                if (squid.vel.y < 0) squid.vel.y *= -0.5;
            } else if (collision.type === 'bottom') {
                squid.pos.y = collision.limit - squid.size/2 - 2;
                if (squid.vel.y > 0) squid.vel.y *= -0.5;
            }

            if (!squid.isInvincible) {
                squid.takeDamage();
                comboCount = 0;
                squid.setEvolution(0); // å—å‚·é€€åŒ–
                shakeAmount = 15;
                playCollisionSound();
                updateHPDisplay();
                if (collision.type === 'top') squid.vel.y = 8;
                else if (collision.type === 'bottom') squid.vel.y = -12;
                
                if (squid.hp <= 0) triggerDeath();
            }
        }
        document.getElementById('score-val').innerText = score;

    } else if (gameState === 2) {
        terrain.display();
        squid.updatePhysicsOnly();
        squid.display();
        
        if (squid.pos.y > height + 100) {
            fill(255, 50, 50); textSize(60); textAlign(CENTER, CENTER);
            text("GAME OVER", width/2, height/2 - 20);
            
            if (canRestart) {
                textSize(30); fill(255);
                let alpha = map(sin(frameCount * 0.1), -1, 1, 100, 255);
                fill(255, 255, 255, alpha);
                text("é»æ“Šç•«é¢ é‡æ–°é–‹å§‹", width/2, height/2 + 60);
            }
        }
    }
    
    // ç²’å­ç³»çµ±æ›´æ–°
    if (random() > 0.8) particles.push(new Bubble(width, random(height), false));
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].display();
        if (particles[i].finished()) particles.splice(i, 1);
    }
    for (let i = stars.length - 1; i >= 0; i--) {
        stars[i].update();
        stars[i].display();
        if (stars[i].finished()) stars.splice(i, 1);
    }
    
    // éé—œé–ƒç™½å…‰
    if (flashScreen > 0) {
        noStroke();
        fill(255, flashScreen);
        rect(0, 0, width, height);
        flashScreen -= 5;
    }
    
    pop();
}

function screenPosition(x, y) { return x; }

function triggerDeath() {
    gameState = 2;
    stopFallingSequence();
    playDieSound();
    squid.explode();
    for(let k=0; k<20; k++) {
        let b = new Bubble(squid.pos.x, squid.pos.y, true);
        b.vel = p5.Vector.random2D().mult(random(5, 10));
        particles.push(b);
    }
    canRestart = false;
    setTimeout(() => { canRestart = true; }, 1500);
}

function handleInput(e) {
    if(e && e.cancelable) e.preventDefault();
    if (!isAudioReady) return false;

    if (gameState === 1) {
        let power = random(0.6, 0.9);
        squid.jump(power);
        playJumpSound(power);
    } else if (gameState === 2 && canRestart) {
        startGame();
    }
    return false;
}

function mousePressed() { return handleInput(null); }
function touchStarted() { return handleInput(null); }

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    squid.reset(width * 0.25, height/2);
}

function drawBackground() {
    let ctx = drawingContext;
    let gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, "#020510");
    gradient.addColorStop(1, "#000000");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
}

// ==========================================
//  PART 3: é¡åˆ¥ (å«é€²åŒ–ç¹ªåœ–)
// ==========================================
class CaveTerrain {
    constructor() { this.reset(true); }
    reset(randomize = false) {
        if(randomize) this.noiseOffset = random(10000);
        else this.noiseOffset = 0;
        this.segments = [];
        for(let x=0; x<=width; x+=10) this.segments.push(this.generateHeight(x));
    }
    generateHeight(x) {
        let n = noise(this.noiseOffset);
        this.noiseOffset += 0.02;
        let gapSize = map(n, 0, 1, 450, 650);
        let center = map(noise(this.noiseOffset * 0.5 + 100), 0, 1, 50, height-50);
        return { x: x, top: center - gapSize/2, bottom: center + gapSize/2 };
    }
    update() {
        for (let s of this.segments) { s.x -= gameSpeed; }
        if (this.segments[0].x < -10) { this.segments.shift(); }
        let lastX = this.segments[this.segments.length-1].x;
        if (lastX < width) { this.segments.push(this.generateHeight(lastX + 10)); }
    }
    display() {
        fill(20, 30, 40); stroke(0, 255, 255, 50);
        beginShape(); vertex(0, 0);
        for (let s of this.segments) vertex(s.x, s.top);
        vertex(width, 0); endShape(CLOSE);
        beginShape(); vertex(0, height);
        for (let s of this.segments) vertex(s.x, s.bottom);
        vertex(width, height); endShape(CLOSE);
    }
    getCenterY(atX) { return map(noise(this.noiseOffset * 0.5 + 100), 0, 1, 50, height-50); }
    checkCollision(squid) {
        for (let s of this.segments) {
            if (abs(s.x - squid.pos.x) < 10) {
                let safeZoneTop = s.top; let safeZoneBot = s.bottom;
                let squidTop = squid.pos.y - squid.size/2 + 5;
                let squidBot = squid.pos.y + squid.size/2 - 5;
                if (squidTop < safeZoneTop) return { hit: true, type: 'top', limit: safeZoneTop };
                if (squidBot > safeZoneBot) return { hit: true, type: 'bottom', limit: safeZoneBot };
            }
        }
        return { hit: false, type: 'none', limit: 0 };
    }
}

class Pearl {
    constructor(x, y) { this.pos = createVector(x, y); this.r = 20; }
    update() { this.pos.x -= gameSpeed; }
    display() {
        noStroke(); fill(255, 255, 200, 100); ellipse(this.pos.x, this.pos.y, this.r * 2.5);
        fill(255); ellipse(this.pos.x, this.pos.y, this.r);
    }
    hits(squid) {
        let d = dist(this.pos.x, this.pos.y, squid.pos.x, squid.pos.y);
        return d < this.r + squid.size;
    }
    offscreen() { return this.pos.x < -50; }
}

class TechSquid {
    constructor(x, y) {
        this.reset(x, y);
        this.size = 60;
        this.baseColor = color(0, 255, 255);
        this.evolutionLevel = 0; // 0=Squid, 1=Cuttlefish, 2=Octopus...
    }
    reset(x, y) {
        this.pos = createVector(x, y); this.vel = createVector(0, 0);
        this.gravity = 0.35; this.drag = 0.95;
        this.bodyColor = this.baseColor; this.squish = 1.0;
        this.tentaclePhase = 0; this.eyeSize = 15;
        this.hp = 3; this.invincibleTimer = 0; this.isInvincible = false;
        this.evolutionLevel = 0;
    }
    setEvolution(level) {
        this.evolutionLevel = level;
        // é€²åŒ–ç‰¹æ•ˆï¼šç¨å¾®è®Šå¤§ä¸€é»
        this.size = 60 + (level * 2);
    }
    takeDamage() {
        this.hp--; this.invincibleTimer = 90; this.isInvincible = true;
        this.bodyColor = color(255, 50, 50);
    }
    jump(power) {
        this.vel.y = -9; this.squish = 0.6;
        if(!this.isInvincible) this.updateColorByLevel();
        this.eyeSize = 25;
        for(let i=0; i<5; i++) particles.push(new Bubble(this.pos.x, this.pos.y + 30, true));
    }
    explode() {
        this.vel.y = -15; this.vel.x = random(-2, 2); this.bodyColor = color(100, 100, 100);
    }
    updatePhysicsOnly() {
        this.vel.y += this.gravity;
        this.pos.add(this.vel);
        this.tentaclePhase += 0.05;
        this.vel.x *= 0.99;
        this.pos.x += this.vel.x;
    }
    updateColorByLevel() {
        // æ ¹æ“šç­‰ç´šæ”¹è®Šé¡è‰²
        if (this.evolutionLevel >= 6) this.bodyColor = color(255, 215, 0); // Gold/God
        else if (this.evolutionLevel >= 4) this.bodyColor = color(255, 100, 255); // Pink/Purple
        else if (this.evolutionLevel >= 2) this.bodyColor = color(100, 255, 100); // Green
        else this.bodyColor = this.baseColor; // Cyan
    }
    update() {
        this.vel.y += this.gravity; this.vel.mult(this.drag); this.pos.add(this.vel);
        this.squish = lerp(this.squish, 1.0 + sin(frameCount*0.1)*0.05, 0.1);
        
        if (this.isInvincible) {
            this.invincibleTimer--;
            if (frameCount % 10 < 5) this.bodyColor = color(255, 100, 100, 150);
            else this.updateColorByLevel();
            if (this.invincibleTimer <= 0) {
                this.isInvincible = false; this.updateColorByLevel();
            }
        } else {
            this.updateColorByLevel();
        }
        this.eyeSize = lerp(this.eyeSize, 15, 0.1); this.tentaclePhase += 0.1;
    }
    
    // â˜… ç¹ªåœ–æ ¸å¿ƒï¼šæ ¹æ“šç­‰ç´šç•«ä¸åŒç”Ÿç‰© â˜…
    display() {
        push(); translate(this.pos.x, this.pos.y);
        if (gameState === 2) rotate(frameCount * 0.2); else rotate(this.vel.y * 0.02);
        
        scale(1, this.squish);
        
        // æ ¹æ“š Combo ç­‰ç´šæ±ºå®šç•«ä»€éº¼
        let level = this.evolutionLevel;
        
        if (level === 0 || level === 1) this.drawSquid();
        else if (level === 2) this.drawCuttlefish();
        else if (level === 3) this.drawOctopus();
        else if (level === 4) this.drawJellyfish();
        else if (level === 5) this.drawSeahorse();
        else if (level >= 6) this.drawAnglerfish();
        
        pop();
    }
    
    // --- å„ç¨®ç”Ÿç‰©çš„ç¹ªåœ–å‡½å¼ ---
    
    drawSquid() { // åŸå‹
        noFill(); strokeWeight(4);
        for(let i=-2; i<=2; i++) {
            stroke(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 200);
            beginShape();
            for(let j=0; j<8; j++) {
                let wave = sin(this.tentaclePhase + i + j*0.5) * j*1.5; vertex(i*10 + wave, 30 + j*8);
            }
            endShape();
        }
        noStroke(); fill(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 150);
        arc(0, 0, this.size*1.8, this.size*1.8, PI, TWO_PI); rect(-this.size*0.9, 0, this.size*1.8, 10);
        this.drawEyes(-20, -10);
    }
    
    drawCuttlefish() { // é€æŠ½ (é•·è±å½¢)
        noFill(); strokeWeight(4);
        for(let i=-1; i<=1; i++) {
            stroke(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 200);
            line(i*10, 40, i*15, 70); // è§¸é¬šè¼ƒç›´
        }
        noStroke(); fill(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 150);
        beginShape(); // è±å½¢èº«é«”
        vertex(0, -50); vertex(30, 0); vertex(0, 50); vertex(-30, 0);
        endShape(CLOSE);
        this.drawEyes(-15, -10);
    }
    
    drawOctopus() { // ç« é­š (åœ“é ­å¤šè…³)
        noFill(); strokeWeight(5);
        for(let i=0; i<8; i++) {
             stroke(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 200);
             let angle = map(i, 0, 8, -PI/2, PI/2);
             let tx = sin(angle + this.tentaclePhase) * 40;
             let ty = 30 + cos(angle) * 30;
             line(0, 10, tx, ty);
        }
        noStroke(); fill(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 150);
        ellipse(0, -10, 60, 50); // åœ“é ­
        this.drawEyes(-15, -15);
    }
    
    drawJellyfish() { // æ°´æ¯ (åŠé€æ˜)
        noFill(); strokeWeight(2);
        for(let i=-3; i<=3; i++) {
            stroke(255, 100);
            let wave = sin(this.tentaclePhase + i*0.5 + frameCount*0.1) * 10;
            line(i*8, 10, i*10 + wave, 60);
        }
        noStroke(); fill(200, 200, 255, 100);
        arc(0, 0, 60, 50, PI, TWO_PI);
        this.drawEyes(-15, -10);
    }
    
    drawSeahorse() { // æµ·é¦¬ (Så‹)
        noFill(); stroke(this.bodyColor); strokeWeight(15);
        beginShape();
        vertex(0, -30);
        bezierVertex(20, -30, 20, 0, 0, 10); // é ­é ¸
        bezierVertex(-20, 20, -20, 40, 10, 50); // å°¾å·´æ²
        endShape();
        noStroke(); fill(255);
        ellipse(5, -25, 10); // çœ¼ç›
        fill(0); ellipse(7, -25, 3);
    }
    
    drawAnglerfish() { // ç‡ˆç± é­š (å…‡çŒ›)
        // ç‡ˆç± 
        stroke(255); strokeWeight(2); line(0, -30, 20, -50);
        noStroke(); fill(255, 255, 0); ellipse(20, -50, 10);
        // èº«é«”
        fill(this.bodyColor);
        ellipse(0, 0, 70, 60);
        // ç‰™é½’
        fill(255);
        triangle(-20, 10, -15, 25, -10, 10);
        triangle(10, 10, 15, 25, 20, 10);
        this.drawEyes(-15, -10);
    }

    drawEyes(x, y) {
        fill(255); noStroke();
        ellipse(x, y, this.eyeSize+5); ellipse(-x, y, this.eyeSize+5);
        fill(0);
        ellipse(x, y + this.vel.y*0.2, 5); ellipse(-x, y + this.vel.y*0.2, 5);
    }
}

class Bubble {
    constructor(x, y, burst) {
        this.pos = createVector(x, y); this.isBurst = burst;
        if(burst) { this.vel = p5.Vector.random2D().mult(random(2, 5)); this.size = random(5, 10); this.alpha = 255; }
        else { this.vel = createVector(-gameSpeed * random(0.5, 1.5), random(-1, 1)); this.size = random(2, 5); this.alpha = random(50, 150); }
    }
    update() { this.pos.add(this.vel); if(this.isBurst) { this.size *= 0.9; this.alpha -= 10; } }
    display() { if(this.alpha <= 0) return; noStroke(); fill(200, 255, 255, this.alpha); ellipse(this.pos.x, this.pos.y, this.size); }
    finished() { return this.alpha < 0 || this.pos.x < 0; }
}

class StarParticle {
    constructor(x, y) {
        this.pos = createVector(x, y); this.vel = p5.Vector.random2D().mult(random(5, 10));
        this.acc = createVector(0, 0.2); this.size = random(10, 20);
        this.alpha = 255; this.rotation = random(TWO_PI); this.rotSpeed = random(-0.2, 0.2);
    }
    update() { this.vel.add(this.acc); this.pos.add(this.vel); this.alpha -= 5; this.rotation += this.rotSpeed; }
    display() {
        if(this.alpha <= 0) return; push(); translate(this.pos.x, this.pos.y); rotate(this.rotation); noStroke();
        fill(255, 215, 0, this.alpha); beginShape();
        for (let i = 0; i < 5; i++) {
            let angle = TWO_PI * i / 5 - HALF_PI; let x = cos(angle) * this.size; let y = sin(angle) * this.size;
            vertex(x, y); angle += TWO_PI / 10;
            let x2 = cos(angle) * (this.size * 0.4); let y2 = sin(angle) * (this.size * 0.4); vertex(x2, y2);
        }
        endShape(CLOSE); pop();
    }
    finished() { return this.alpha < 0; }
}
</script>
</body>
</html>
