<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Cyber Squid - MB02 Fix</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

  <style>
    body { margin: 0; padding: 0; background: #000; overflow: hidden; touch-action: none; font-family: 'Courier New', monospace; }
    
    #overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to bottom, #051020, #000);
      display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 999;
      color: #0ff; text-align: center;
    }
    
    .btn-group { display: flex; gap: 20px; margin-top: 30px; }
    
    button {
      padding: 15px 40px; font-size: 20px; color: #0ff;
      background: rgba(0, 255, 255, 0.1); border: 2px solid #0ff; border-radius: 50px;
      cursor: pointer; letter-spacing: 2px;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
      transition: all 0.2s;
    }
    button:hover { background: rgba(0, 255, 255, 0.3); transform: scale(1.05); }
    button:active { transform: scale(0.95); }
    button:disabled { border-color: #555; color: #555; cursor: not-allowed; }

    #ble-status {
        margin-top: 15px; font-size: 14px; color: #888;
        display: flex; align-items: center; gap: 10px; flex-direction: column;
    }
    
    #hud {
      position: absolute; top: 20px; left: 20px; color: #0ff;
      font-size: 24px; pointer-events: none; text-shadow: 0 0 5px #0ff;
      display: none; font-weight: bold;
    }
    
    #hp-bar {
        position: absolute; top: 20px; right: 20px;
        font-size: 30px; color: #ff5555; text-shadow: 0 0 5px #f00;
        display: none;
        text-align: right;
    }

    .combo-text {
        position: absolute; color: #ffff00; font-weight: bold; font-size: 24px;
        pointer-events: none; animation: floatUp 1s forwards; text-shadow: 0 0 10px #ffaa00; z-index: 10;
    }
    .jackpot-text {
        position: absolute; color: #FFD700; font-weight: bold; font-size: 50px;
        pointer-events: none; animation: zoomOut 3s forwards; text-shadow: 0 0 30px #ffffff;
        z-index: 20; width: 100%; text-align: center; top: 35%;
    }
    .evo-text {
        position: absolute; color: #00ffff; font-weight: bold; font-size: 40px;
        pointer-events: none; animation: zoomOut 2s forwards; text-shadow: 0 0 20px #ffffff;
        z-index: 20; width: 100%; text-align: center; top: 30%;
    }
    
    @keyframes floatUp {
        0% { transform: translateY(0) scale(1); opacity: 1; }
        50% { transform: translateY(-30px) scale(1.5); opacity: 1; }
        100% { transform: translateY(-60px) scale(1); opacity: 0; }
    }
    @keyframes zoomOut {
        0% { transform: scale(0.5); opacity: 0; }
        50% { transform: scale(1.2); opacity: 1; }
        100% { transform: scale(2.0); opacity: 0; }
    }
  </style>
</head>
<body>

  <div id="hud">SCORE: <span id="score-val">0</span></div>
  <div id="hp-bar">â¤â¤â¤</div>

  <div id="overlay">
    <h1 style="text-shadow: 0 0 20px #0ff; font-size: 50px; margin-bottom: 0;">æ·±æµ·çƒè³Š</h1>
    <p style="color: #0aa; font-size: 20px;">MB02 å°ˆç”¨é€£ç·šç‰ˆ</p>
    
    <div class="btn-group">
        <button id="ble-btn">ğŸ”µ é€£æ¥æ¡åŠ›çƒ</button>
        <button id="start-btn">é–‹å§‹å†’éšª</button>
    </div>
    
    <div id="ble-status">
        <span id="p1-status" style="color: #888;">P1: æœªé€£æ¥</span>
        <span id="data-debug" style="color: #555; font-size: 12px; margin-top:5px;">Waiting...</span>
    </div>
  </div>

<script>
// ==========================================
//  PART 0: MB02 å°ˆç”¨ Web Bluetooth
// ==========================================
let bluetoothDevice;
let gripCharacteristic;
let lastDataValue = null;

// â˜… é—œéµï¼šå¸¸ç”¨çš„ä½åŠŸè€—è—ç‰™æœå‹™ UUID åˆ—è¡¨ â˜…
// é€™è£¡åˆ—å‡ºäº†å¸‚é¢ä¸Š 90% æ¡åŠ›çƒå¯èƒ½ä½¿ç”¨çš„ UUIDï¼Œç¢ºä¿ç€è¦½å™¨å…è¨±é€£ç·š
const OPTIONAL_SERVICES = [
    "0000fff0-0000-1000-8000-00805f9b34fb", // é€šç”¨ Generic
    "0000ffe0-0000-1000-8000-00805f9b34fb", // HM-10 / CC2541
    "0000fee7-0000-1000-8000-00805f9b34fb", // Tencent/WeChat
    "6e400001-b5a3-f393-e0a9-e50e24dcca9e", // Nordic UART
    "0000180d-0000-1000-8000-00805f9b34fb"  // Heart Rate (æœ‰äº›æ¡åŠ›çƒæœƒå½è£æˆå¿ƒç‡å¸¶)
];

// æª¢æŸ¥è—ç‰™æ”¯æ´
if (!navigator.bluetooth) {
    document.getElementById('ble-status').innerText = "âš ï¸ æ­¤ç€è¦½å™¨ä¸æ”¯æ´ Web Bluetooth";
}

async function connectBLE() {
    const statusMsg = document.getElementById('p1-status');
    const debugMsg = document.getElementById('data-debug');
    
    try {
        statusMsg.innerText = "è«‹é¸æ“‡ MB02...";
        
        // 1. è«‹æ±‚è£ç½® (åªéæ¿¾ MB é–‹é ­çš„è£ç½®)
        const device = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: "MB" }], // â˜… åªæŠ“ MB02, MBxx
            optionalServices: OPTIONAL_SERVICES // â˜… å¿…é ˆåˆ—å‡ºæ‰€æœ‰å¯èƒ½çš„ UUIDï¼Œå¦å‰‡æœƒé€£æ¥å¤±æ•—
        });

        statusMsg.innerText = "é€£æ¥ GATT Server...";
        const server = await device.gatt.connect();
        
        statusMsg.innerText = "å°‹æ‰¾æœå‹™...";
        
        // 2. è°æ˜æœå°‹ï¼šéæ­·æ‰€æœ‰æœå‹™ï¼Œæ‰¾åˆ°ç¬¬ä¸€å€‹èƒ½ Notify çš„ç‰¹å¾µå€¼
        const services = await server.getPrimaryServices();
        let targetChar = null;

        // é›™å±¤è¿´åœˆæ‰¾ç‰¹å¾µå€¼
        for (const service of services) {
            console.log("Checking Service:", service.uuid);
            try {
                const characteristics = await service.getCharacteristics();
                for (const c of characteristics) {
                    // æª¢æŸ¥æ˜¯å¦æœ‰ notify æˆ– indicate å±¬æ€§
                    if (c.properties.notify || c.properties.indicate) {
                        console.log("Found Notify Char:", c.uuid);
                        targetChar = c;
                        break;
                    }
                }
            } catch(e) { console.log("Skip service restricted"); }
            if (targetChar) break;
        }
        
        if (!targetChar) throw new Error("æ‰¾ä¸åˆ°å¯è®€å–çš„æ•¸æ“šç‰¹å¾µå€¼ (No Notify)");
        
        // 3. è¨‚é–±
        await targetChar.startNotifications();
        targetChar.addEventListener('characteristicvaluechanged', handleBLEData);
        
        // UI æ›´æ–°
        statusMsg.innerText = `å·²é€£ç·š: ${device.name}`;
        statusMsg.style.color = "#0f0";
        debugMsg.innerText = "æº–å‚™å°±ç·’ï¼Œè«‹æ¡å£“!";
        document.getElementById('ble-btn').innerText = "å·²é€£ç·š";
        document.getElementById('ble-btn').disabled = true;

    } catch (error) {
        console.error("BLE Error:", error);
        statusMsg.innerText = "é€£ç·šå¤±æ•—";
        statusMsg.style.color = "red";
        debugMsg.innerText = error.message;
        // å¦‚æœæ˜¯å› ç‚º UUID ä¸åœ¨åˆ—è¡¨ï¼Œé€™è£¡æœƒé¡¯ç¤ºéŒ¯èª¤
        if(error.name === 'NotFoundError') {
             debugMsg.innerText = "ä½¿ç”¨è€…å–æ¶ˆæˆ–æœªé¸æ“‡";
        } else if (error.name === 'SecurityError') {
             debugMsg.innerText = "å®‰å…¨æ€§éŒ¯èª¤ (è«‹ç¢ºèª HTTPS)";
        }
    }
}

function handleBLEData(event) {
    const value = event.target.value;
    
    // å°‡ DataView çš„æ‰€æœ‰ bytes åŠ ç¸½ï¼Œç•¶ä½œä¸€ç¨®ç°¡å–®çš„ Hash
    // å› ç‚ºæˆ‘å€‘ä¸çŸ¥é“å…·é«”å“ªå€‹ byte æ˜¯æ­¥æ•¸ï¼Œä½†åªè¦ç¸½å’Œè®Šäº†ï¼Œé€šå¸¸ä»£è¡¨æ•¸å€¼è®Šäº†
    let currentSum = 0;
    for (let i = 0; i < value.byteLength; i++) {
        currentSum += value.getUint8(i);
    }
    
    // å¦‚æœæ•¸æ“šæ”¹è®Šäº† (ä»£è¡¨æœ‰å‹•ä½œ)
    if (lastDataValue !== null && currentSum !== lastDataValue) {
        // æ›´æ–° Debug
        document.getElementById('data-debug').innerText = `Signal: ${currentSum}`;
        document.getElementById('data-debug').style.color = "#fff";
        setTimeout(() => document.getElementById('data-debug').style.color = "#555", 100);
        
        // è§¸ç™¼è·³èº (åƒ…åœ¨éŠæˆ²ä¸­)
        if (gameState === 1) {
            triggerPlayerAction();
        }
    }
    lastDataValue = currentSum;
}

// çµ±ä¸€è§¸ç™¼
function triggerPlayerAction() {
    if (!squid) return;
    let power = random(0.6, 0.9);
    squid.jump(power);
    playJumpSound(power);
}

// ==========================================
//  PART 1: è²éŸ³ç³»çµ± (æ–¹æ³¢æ±  + æ¥é¾ + æ·±æµ·)
// ==========================================
let jumpSynth, fallSynth, collectSynth, collisionSynth, levelUpSynth, jackpotSynth, victorySynth, dieSynth;
let ambientNoise;
let pearlSynths = [];
let pearlSynthIndex = 0;

let isAudioReady = false;
let audioInitStarted = false;
let lastJumpPitch = 600;
let fallTimeoutID = null;
let isFallingSoundPlaying = false;

const noteMap = ["C5", "D5", "E5", "G5", "A5", "C6", "D6", "E6", "G6", "A6", "C7", "E7", "G7"];

async function initAudio() {
    if (audioInitStarted) return;
    audioInitStarted = true;
    
    const btn = document.getElementById('start-btn');
    btn.innerText = "å•Ÿå‹•ä¸­...";
    
    try {
        await Tone.start();
        if (Tone.context.state !== 'running') await Tone.context.resume();
        Tone.Destination.volume.value = 0;

        jumpSynth = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: { attack: 0.02, decay: 0.3, sustain: 0, release: 0.5 }
        }).toDestination();
        jumpSynth.volume.value = -2;

        fallSynth = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }
        }).toDestination();
        fallSynth.volume.value = -5;

        // Collect (Square Pool - æ‚¨æœ€æ„›çš„)
        for(let i=0; i<15; i++) {
            let s = new Tone.Synth({
                oscillator: { type: "square" },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }
            }).toDestination();
            s.volume.value = -12;
            pearlSynths.push(s);
        }
        
        levelUpSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sawtooth" },
            envelope: { attack: 0.05, decay: 0.5, sustain: 0.3, release: 1.5 }
        }).toDestination();
        levelUpSynth.volume.value = -8;

        jackpotSynth = new Tone.Synth({
            oscillator: { type: "square" },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 }
        }).toDestination();
        jackpotSynth.volume.value = -10;

        victorySynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "fatsawtooth", count: 3, spread: 30 },
            envelope: { attack: 0.1, decay: 0.5, sustain: 1.0, release: 4.0 }
        }).toDestination();
        victorySynth.volume.value = -15;

        collisionSynth = new Tone.FMSynth({
            harmonicity: 3.0, modulationIndex: 10, oscillator: { type: "sine" }, modulation: { type: "square" },
            envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.3 },
            modulationEnvelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.3 }
        }).toDestination();
        collisionSynth.volume.value = -2;
        
        dieSynth = new Tone.NoiseSynth({
            noise: { type: "brown" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0 }
        }).toDestination();
        dieSynth.volume.value = -2;

        let filter = new Tone.Filter(200, "lowpass").toDestination();
        ambientNoise = new Tone.Noise("brown").connect(filter);
        ambientNoise.volume.value = -22;
        ambientNoise.start();

        const testBeep = new Tone.Synth().toDestination();
        testBeep.triggerAttackRelease("C6", "32n");

        isAudioReady = true;
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        document.getElementById('hp-bar').style.display = 'block';
        startCountdown();

    } catch (e) {
        console.error("Audio Init Error:", e);
        document.getElementById('status-msg').innerText = "éŸ³æ•ˆå•Ÿå‹•å¤±æ•—";
    }
}

function playJumpSound(power) {
    if (!isAudioReady) return;
    stopFallingSequence();
    let pitch = map(power, 0.0, 1.0, 300, 700);
    lastJumpPitch = pitch;
    
    if (squid && squid.evolutionLevel >= 5) {
        jumpSynth.oscillator.type = "square"; jumpSynth.volume.value = -12;
    } else {
        jumpSynth.oscillator.type = "sine"; jumpSynth.volume.value = -2;
    }
    try { jumpSynth.triggerAttackRelease(pitch, "8n"); } catch(e){}
}

function playCountdownBeep(pitch) {
    if (!isAudioReady) return;
    try {
        jumpSynth.oscillator.type = "sine"; jumpSynth.volume.value = -5;
        jumpSynth.triggerAttackRelease(pitch, "32n");
    } catch(e){}
}

function playCollectSound(comboIndex) {
    if (!isAudioReady) return;
    let index = (comboIndex % 10);
    let note = noteMap[index];
    try {
        pearlSynths[pearlSynthIndex].triggerAttackRelease(note, "32n");
        pearlSynthIndex = (pearlSynthIndex + 1) % pearlSynths.length;
    } catch(e){}
}

function playLevelUpSound() {
    if (!isAudioReady) return;
    try { levelUpSynth.triggerAttackRelease(["C5", "E5", "G5", "C6"], "8n"); } catch(e){}
}

function playJackpotSound() {
    if (!isAudioReady) return;
    let now = Tone.now();
    let notes = ["C6", "B5", "A5", "G5", "F5", "E5", "D5", "C5", "B4", "A4", "G4", "F4", "E4", "D4", "C4"];
    for (let i = 0; i < notes.length; i++) {
        jackpotSynth.triggerAttackRelease(notes[i], "32n", now + (i * 0.05));
    }
}

function playVictorySound() {
    if (!isAudioReady) return;
    try { victorySynth.triggerAttackRelease(["C3", "G3", "C4", "E4", "G4", "C5", "E5", "C6"], "1n"); } catch(e){}
}

function playCollisionSound() {
    if (!isAudioReady) return;
    try { collisionSynth.triggerAttackRelease("C3", "8n"); collisionSynth.frequency.rampTo("C2", 0.1); } catch(e){}
}

function playDieSound() {
    if (!isAudioReady) return;
    try { dieSynth.triggerAttackRelease("4n"); collisionSynth.triggerAttackRelease("C2", "2n"); collisionSynth.frequency.rampTo("C1", 1); } catch(e){}
}

function startFallingSequence() {
    if (!isAudioReady || isFallingSoundPlaying) return;
    isFallingSoundPlaying = true;
    let currentPitch = lastJumpPitch; let currentGap = 0.15; let currentVol = -5;
    if (squid && squid.evolutionLevel >= 5) { fallSynth.oscillator.type = "square"; fallSynth.volume.value = -12; }
    else { fallSynth.oscillator.type = "sine"; fallSynth.volume.value = -5; }

    function playBeat() {
        if (!isFallingSoundPlaying) return;
        let now = Tone.now();
        try { fallSynth.triggerAttackRelease(currentPitch, currentGap * 0.8, now, Tone.dbToGain(currentVol)); } catch(e){}
        currentPitch *= 0.85; currentGap *= 0.8; currentVol -= 2;
        if (currentPitch > 50 && currentGap > 0.02) {
            fallTimeoutID = setTimeout(playBeat, currentGap * 1000);
        } else { isFallingSoundPlaying = false; }
    }
    playBeat();
}
function stopFallingSequence() {
    isFallingSoundPlaying = false;
    if (fallTimeoutID) { clearTimeout(fallTimeoutID); fallTimeoutID = null; }
}

// ==========================================
//  PART 2: éŠæˆ²é‚è¼¯ (ç´¯ç©é€²åŒ–)
// ==========================================
let squid;
let particles = []; let stars = []; let terrain; let pearls = [];
let gameState = 0; let score = 0; let gameSpeed = 3; let shakeAmount = 0; let canRestart = false;
let comboCount = 0; let comboTimer = 0;
let totalPearls = 0;
const COMBO_TIME_LIMIT = 300;
const VICTORY_PEARLS = 60;

let startCountdownTimer = 0;

function setup() {
    createCanvas(windowWidth, windowHeight);
    squid = new TechSquid(width * 0.25, height/2);
    terrain = new CaveTerrain();
    
    document.getElementById('start-btn').onclick = initAudio;
    document.getElementById('ble-btn').onclick = connectBLE;
    
    noLoop();
}

function startCountdown() {
    if (!squid) squid = new TechSquid(width * 0.25, height/2);
    else {
        squid.reset(width * 0.25, height/2);
        squid.evolutionLevel = 0;
        squid.updateColorByLevel();
        squid.size = 60;
    }
    terrain.reset(true);
    pearls = []; particles = []; stars = [];
    
    score = 0;
    comboCount = 0;
    totalPearls = 0;
    
    gameState = 4; // Countdown
    startCountdownTimer = 180;
    updateHPDisplay();
    loop();
}

function startGame() {
    gameState = 1; score = 0; gameSpeed = 3.5;
    updateHPDisplay();
}

function updateHPDisplay() {
    let hp = squid.hp;
    let hpElement = document.getElementById('hp-bar');
    let heartSymbol = "â¤"; let color = "#ff5555";
    if (hp > 20) { heartSymbol = "ğŸ‘‘"; color = "#ffd700"; }
    else if (hp > 10) { heartSymbol = "ğŸ’›"; color = "#ffff00"; }
    else if (hp > 5) { heartSymbol = "ğŸ’™"; color = "#00ffff"; }
    if (hp > 15) { hpElement.innerText = heartSymbol + " x" + hp; }
    else { let str = ""; for(let i=0; i<hp; i++) str += heartSymbol; hpElement.innerText = str; }
    hpElement.style.color = color; hpElement.style.textShadow = `0 0 5px ${color}`;
}

function showComboText(x, y, count) {
    let el = document.createElement('div');
    el.className = 'combo-text'; el.style.left = x + 'px'; el.style.top = y + 'px';
    el.innerText = count > 1 ? "COMBO x" + count + "!" : "NICE!";
    if(count > 5) el.style.color = "#ff00ff";
    document.body.appendChild(el); setTimeout(() => { document.body.removeChild(el); }, 1000);
}

function showEvoText(text) {
    let el = document.createElement('div');
    el.className = 'evo-text'; el.innerHTML = text;
    document.body.appendChild(el); setTimeout(() => { document.body.removeChild(el); }, 2000);
}

function showJackpotText() {
    let el = document.createElement('div');
    el.className = 'jackpot-text'; el.innerHTML = "JACKPOT!<br>SUPER SQUID MODE!";
    document.body.appendChild(el); setTimeout(() => { document.body.removeChild(el); }, 3000);
}

function draw() {
    push();
    if (shakeAmount > 0) {
        translate(random(-shakeAmount, shakeAmount), random(-shakeAmount, shakeAmount));
        shakeAmount *= 0.9;
        if(shakeAmount < 0.5) shakeAmount = 0;
    }
    
    if (gameState === 3) {
        let ctx = drawingContext;
        let g = ctx.createLinearGradient(0, 0, 0, height);
        g.addColorStop(0, "#FFFFE0"); g.addColorStop(1, "#FFD700");
        ctx.fillStyle = g; ctx.fillRect(0,0,width,height);
    } else {
        drawBackground();
    }

    if (gameState === 4) {
        terrain.display();
        squid.display();
        startCountdownTimer--;
        let seconds = ceil(startCountdownTimer / 60);
        if (startCountdownTimer % 60 === 0 && startCountdownTimer > 0) playCountdownBeep("C5");
        if (startCountdownTimer === 0) playCountdownBeep("C6");

        textAlign(CENTER, CENTER); textStyle(BOLD); textSize(150);
        if (startCountdownTimer > 0) { fill(255); text(seconds, width/2, height/2); }
        else { fill(0, 255, 255); text("GO!", width/2, height/2); }
        
        if (startCountdownTimer < -30) startGame();

    } else if (gameState === 1) {
        gameSpeed += 0.0002;
        
        let hasPearlOnScreen = pearls.some(p => p.pos.x > 0 && p.pos.x < width);
        if (comboCount > 0) {
            if (hasPearlOnScreen) comboTimer--;
            if (comboTimer <= 0) comboCount = 0;
        }
        
        terrain.update();
        terrain.display();

        if (frameCount % 80 === 0 && random() > 0.2) {
            pearls.push(new Pearl(width, terrain.getCenterY(width)));
        }
        for (let i = pearls.length - 1; i >= 0; i--) {
            let p = pearls[i];
            p.update();
            p.display();
            
            if (p.hits(squid)) {
                comboCount++;
                totalPearls++;
                comboTimer = COMBO_TIME_LIMIT;
                score += 100 + (comboCount * 50);
                
                let potentialLevel = floor(totalPearls / 10);
                if (potentialLevel <= 5 && potentialLevel > squid.evolutionLevel) {
                    squid.setEvolution(potentialLevel);
                    playLevelUpSound();
                    let names = ["", "é€æŠ½é€²åŒ–!", "æ°´æ¯é€²åŒ–!", "æµ·é¦¬é€²åŒ–!", "ç‡ˆç± é­šé€²åŒ–!", "é»ƒé‡‘éœ¸ä¸»!"];
                    showEvoText(names[potentialLevel]);
                    squid.hp++;
                    updateHPDisplay();
                    for(let k=0; k<20; k++) stars.push(new StarParticle(p.pos.x, p.pos.y));
                }
                
                if (totalPearls >= VICTORY_PEARLS) {
                    triggerVictory();
                } else if (comboCount > 0 && comboCount % 10 === 0) {
                    playJackpotSound();
                    score += 1000;
                    showJackpotText();
                    for(let k=0; k<30; k++) stars.push(new StarParticle(p.pos.x, p.pos.y));
                } else {
                    playCollectSound(comboCount);
                    showComboText(screenPosition(p.pos.x), screenPosition(p.pos.y), comboCount);
                    for(let k=0; k<8; k++) particles.push(new Bubble(p.pos.x, p.pos.y, true));
                }
                pearls.splice(i, 1);
            } else if (p.offscreen()) {
                pearls.splice(i, 1);
            }
        }

        squid.update();
        squid.display();
        
        if (squid.pos.x < -squid.size) { squid.hp = 0; triggerDeath(); }
        
        if (squid.vel.y > 2.5 && !isFallingSoundPlaying) startFallingSequence();

        let collision = terrain.checkCollision(squid);
        let obstacleHit = terrain.checkObstacleCollision(squid);

        if (collision.hit || obstacleHit) {
            if (collision.type === 'top') {
                squid.pos.y = collision.limit + squid.size/2 + 2;
                if (squid.vel.y < 0) squid.vel.y *= -0.5;
            } else if (collision.type === 'bottom') {
                squid.pos.y = collision.limit - squid.size/2 - 2;
                if (squid.vel.y > 0) squid.vel.y *= -0.5;
            } else if (obstacleHit) {
                squid.vel.x = -8; squid.vel.y = random(-5, 5);
            }

            if (!squid.isInvincible) {
                squid.takeDamage();
                comboCount = 0;
                shakeAmount = 15;
                playCollisionSound();
                updateHPDisplay();
                if (collision.type === 'top') squid.vel.y = 8;
                else if (collision.type === 'bottom') squid.vel.y = -12;
                if (squid.hp <= 0) triggerDeath();
            }
        }
        document.getElementById('score-val').innerText = score;

    } else if (gameState === 2) {
        terrain.display();
        squid.updatePhysicsOnly();
        squid.display();
        
        if (squid.pos.y > height + 100) {
            fill(255, 50, 50); textSize(60); textAlign(CENTER, CENTER);
            text("GAME OVER", width/2, height/2 - 20);
            if (canRestart) {
                textSize(30); fill(255);
                let alpha = map(sin(frameCount * 0.1), -1, 1, 100, 255);
                fill(255, 255, 255, alpha);
                text("é»æ“Šç•«é¢ é‡æ–°é–‹å§‹", width/2, height/2 + 60);
            }
        }
    } else if (gameState === 3) {
        fill(0); textSize(60); textAlign(CENTER, CENTER);
        text("VICTORY!", width/2, height/2 - 40);
        text("å®Œå…¨åˆ¶éœ¸", width/2, height/2 + 40);
        textSize(30);
        if (frameCount % 60 < 30) text("é»æ“Šç•«é¢ é‡æ–°æŒ‘æˆ°", width/2, height/2 + 120);
        
        if (random() > 0.5) stars.push(new StarParticle(random(width), random(height)));
        for (let i = stars.length - 1; i >= 0; i--) {
            stars[i].update(); stars[i].display();
            if (stars[i].finished()) stars.splice(i, 1);
        }
    }
    
    if (gameState !== 3 && random() > 0.8) particles.push(new Bubble(width, random(height), false));
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(); particles[i].display();
        if (particles[i].finished()) particles.splice(i, 1);
    }
    if(gameState !== 3) {
        for (let i = stars.length - 1; i >= 0; i--) {
            stars[i].update(); stars[i].display();
            if (stars[i].finished()) stars.splice(i, 1);
        }
    }
    
    if (gameState === 1 && comboCount > 0) {
        let barWidth = map(comboTimer, 0, COMBO_TIME_LIMIT, 0, 200);
        let hasPearlOnScreen = pearls.some(p => p.pos.x > 0 && p.pos.x < width);
        noStroke();
        if (hasPearlOnScreen) fill(255, 255, 0, 200);
        else fill(255, 255, 255, 100);
        rect(width/2 - 100, 80, barWidth, 10, 5);
    }

    pop();
}

function screenPosition(x, y) { return x; }

function triggerDeath() {
    gameState = 2; stopFallingSequence(); playDieSound();
    squid.explode();
    for(let k=0; k<20; k++) {
        let b = new Bubble(squid.pos.x, squid.pos.y, true);
        b.vel = p5.Vector.random2D().mult(random(5, 10));
        particles.push(b);
    }
    canRestart = false; setTimeout(() => { canRestart = true; }, 1500);
}

function triggerVictory() {
    gameState = 3; stopFallingSequence();
    playVictorySound();
    canRestart = false; setTimeout(() => { canRestart = true; }, 4000);
}

function handleInput(e) {
    if(e && e.cancelable) e.preventDefault();
    
    if (gameState === 1) {
        triggerPlayerAction();
    } else if ((gameState === 2 || gameState === 3) && canRestart) {
        squid.evolutionLevel = 0;
        startCountdown();
    }
    return false;
}

function mousePressed() { if (gameState !== 0) return handleInput(null); }
function touchStarted() { if (gameState !== 0) return handleInput(null); }

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    if(squid) squid.pos.x = width * 0.25;
}

function drawBackground() {
    let ctx = drawingContext;
    let gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, "#020510");
    gradient.addColorStop(1, "#000000");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
}

// ==========================================
//  PART 3: é¡åˆ¥
// ==========================================

class CaveObstacle {
    constructor(x, y, type, side) {
        this.pos = createVector(x, y); this.type = type; this.side = side; this.size = 40;
        this.angle = random(TWO_PI); this.timer = random(100);
        this.leftEyeSize = random(3, 5); this.rightEyeSize = random(3, 5);
        this.pupilOffsetLeft = createVector(random(-1, 1), random(-1, 1));
        this.pupilOffsetRight = createVector(random(-1, 1), random(-1, 1));
    }
    update() {
        this.pos.x -= gameSpeed; this.timer += 0.05;
        if(frameCount % 20 === 0) {
             this.pupilOffsetLeft = createVector(random(-1, 1), random(-1, 1));
             this.pupilOffsetRight = createVector(random(-1, 1), random(-1, 1));
        }
    }
    display() {
        push(); translate(this.pos.x, this.pos.y);
        if (this.type === 'starfish') {
            rotate(this.angle + this.timer * 0.5); noStroke(); fill(255, 100, 100);
            beginShape(); for (let i = 0; i < 5; i++) {
                let a = TWO_PI * i / 5 - HALF_PI; let r = this.size / 2;
                vertex(cos(a) * r, sin(a) * r); a += TWO_PI / 10; vertex(cos(a) * r * 0.4, sin(a) * r * 0.4);
            } endShape(CLOSE); fill(255, 200); ellipse(0, 0, 5, 5);
        } else if (this.type === 'eel') {
            let sway = sin(this.timer) * 15; let dir = (this.side === 'top') ? 1 : -1;
            noFill(); stroke(240); strokeWeight(14);
            beginShape(); vertex(0, 0); bezierVertex(0, 20*dir, sway, 40*dir, sway*0.5, 70*dir); endShape();
            noStroke(); fill(50); ellipse(0, 15*dir, 5, 5); ellipse(sway*0.3, 40*dir, 5, 5);
            fill(240); let headX = sway*0.5; let headY = 70*dir; ellipse(headX, headY, 20, 24);
            fill(255); ellipse(headX - 5, headY - 2, this.leftEyeSize+2, this.leftEyeSize+2);
            ellipse(headX + 5, headY + 2, this.rightEyeSize+2, this.rightEyeSize+2);
            fill(0); ellipse(headX - 5 + this.pupilOffsetLeft.x, headY - 2 + this.pupilOffsetLeft.y, 2, 2);
            ellipse(headX + 5 + this.pupilOffsetRight.x, headY + 2 + this.pupilOffsetRight.y, 2, 2);
        }
        pop();
    }
    checkCollision(squid) {
        let hitDist = this.size/2 + squid.size/2; let offsetY = 0;
        if (this.type === 'eel') { let dir = (this.side === 'top') ? 1 : -1; offsetY = 70 * dir; }
        let d = dist(this.pos.x, this.pos.y + offsetY, squid.pos.x, squid.pos.y); return d < hitDist;
    }
}

class CaveTerrain {
    constructor() { this.reset(true); }
    reset(randomize = false) {
        if(randomize) this.noiseOffset = random(10000); else this.noiseOffset = 0;
        this.segments = []; this.obstacles = [];
        for(let x=0; x<=width; x+=10) this.addSegment(x);
    }
    addSegment(x) {
        let h = this.generateHeight(x); this.segments.push(h);
        if (random() < 0.05 && x > 400) {
            let type = random() < 0.5 ? 'starfish' : 'eel'; let side = random() < 0.5 ? 'top' : 'bottom';
            let y = (side === 'top') ? h.top : h.bottom; let offset = (side === 'top') ? -10 : 10; if (type === 'eel') offset = 0;
            this.obstacles.push(new CaveObstacle(x, y + offset, type, side));
        }
    }
    generateHeight(x) {
        if (x < 400) { return { x: x, top: height * 0.2, bottom: height * 0.8 }; }
        let n = noise(this.noiseOffset); this.noiseOffset += 0.02;
        let gapSize = map(n, 0, 1, 450, 650);
        let center = map(noise(this.noiseOffset * 0.5 + 100), 0, 1, 50, height-50);
        return { x: x, top: center - gapSize/2, bottom: center + gapSize/2 };
    }
    update() {
        for (let s of this.segments) { s.x -= gameSpeed; }
        if (this.segments[0].x < -10) { this.segments.shift(); }
        let lastX = this.segments[this.segments.length-1].x;
        if (lastX < width) { this.addSegment(lastX + 10); }
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            this.obstacles[i].update();
            if (this.obstacles[i].pos.x < -50) this.obstacles.splice(i, 1);
        }
    }
    display() {
        fill(20, 30, 40); stroke(0, 255, 255, 50);
        beginShape(); vertex(0, 0); for (let s of this.segments) vertex(s.x, s.top); vertex(width, 0); endShape(CLOSE);
        beginShape(); vertex(0, height); for (let s of this.segments) vertex(s.x, s.bottom); vertex(width, height); endShape(CLOSE);
        for (let o of this.obstacles) o.display();
    }
    getCenterY(atX) { return map(noise(this.noiseOffset * 0.5 + 100), 0, 1, 50, height-50); }
    checkCollision(squid) {
        for (let s of this.segments) {
            if (abs(s.x - squid.pos.x) < 10) {
                let safeZoneTop = s.top; let safeZoneBot = s.bottom;
                let squidTop = squid.pos.y - squid.size/2 + 5; let squidBot = squid.pos.y + squid.size/2 - 5;
                if (squidTop < safeZoneTop) return { hit: true, type: 'top', limit: safeZoneTop };
                if (squidBot > safeZoneBot) return { hit: true, type: 'bottom', limit: safeZoneBot };
            }
        }
        return { hit: false, type: 'none', limit: 0 };
    }
    checkObstacleCollision(squid) {
        for (let o of this.obstacles) { if (o.checkCollision(squid)) return true; } return false;
    }
}

class Pearl {
    constructor(x, y) { this.pos = createVector(x, y); this.r = 20; }
    update() { this.pos.x -= gameSpeed; }
    display() { noStroke(); fill(255, 255, 200, 100); ellipse(this.pos.x, this.pos.y, this.r * 2.5); fill(255); ellipse(this.pos.x, this.pos.y, this.r); }
    hits(squid) { let d = dist(this.pos.x, this.pos.y, squid.pos.x, squid.pos.y); return d < this.r + squid.size; }
    offscreen() { return this.pos.x < -50; }
}

class TechSquid {
    constructor(x, y) { this.reset(x, y); this.size = 60; this.baseColor = color(0, 255, 255); this.evolutionLevel = 0; }
    reset(x, y) {
        this.pos = createVector(x, y); this.vel = createVector(0, 0); this.gravity = 0.35; this.drag = 0.95;
        this.bodyColor = this.baseColor; this.squish = 1.0; this.tentaclePhase = 0; this.eyeSize = 15;
        this.hp = 3; this.invincibleTimer = 0; this.isInvincible = false; this.evolutionLevel = 0;
    }
    setEvolution(level) {
        this.evolutionLevel = level;
        this.size = 60 + (min(level, 5) * 5);
    }
    evolveNext() { this.setEvolution(min(this.evolutionLevel + 1, 5)); }
    takeDamage() { this.hp--; this.invincibleTimer = 90; this.isInvincible = true; this.bodyColor = color(255, 50, 50); }
    jump(power) {
        this.vel.y = -9; this.squish = 0.6; if(!this.isInvincible) this.updateColorByLevel();
        this.eyeSize = 25; for(let i=0; i<5; i++) particles.push(new Bubble(this.pos.x, this.pos.y + 30, true));
    }
    explode() { this.vel.y = -15; this.vel.x = random(-2, 2); this.bodyColor = color(100, 100, 100); }
    updatePhysicsOnly() {
        this.vel.y += this.gravity; this.pos.add(this.vel); this.tentaclePhase += 0.05; this.vel.x *= 0.99; this.pos.x += this.vel.x;
    }
    updateColorByLevel() {
        if (this.evolutionLevel >= 5) this.bodyColor = color(255, 215, 0);
        else if (this.evolutionLevel === 4) this.bodyColor = color(50, 50, 100);
        else if (this.evolutionLevel === 3) this.bodyColor = color(100, 200, 100);
        else if (this.evolutionLevel === 2) this.bodyColor = color(200, 200, 255);
        else if (this.evolutionLevel === 1) this.bodyColor = color(255, 150, 150);
        else this.bodyColor = this.baseColor;
    }
    update() {
        this.vel.y += this.gravity; this.vel.mult(this.drag); this.pos.add(this.vel);
        this.squish = lerp(this.squish, 1.0 + sin(frameCount*0.1)*0.05, 0.1);
        if (this.isInvincible) {
            this.invincibleTimer--;
            if (frameCount % 10 < 5) this.bodyColor = color(255, 100, 100, 150); else this.updateColorByLevel();
            if (this.invincibleTimer <= 0) { this.isInvincible = false; this.updateColorByLevel(); }
        } else {
            if(this.evolutionLevel >= 5) this.bodyColor = lerpColor(color(255, 215, 0), color(255, 255, 100), sin(frameCount*0.2)*0.5 + 0.5);
            else this.updateColorByLevel();
        }
        let targetX = width * 0.25;
        let diff = targetX - this.pos.x;
        this.vel.x += diff * 0.01; this.vel.x *= 0.9;
        this.eyeSize = lerp(this.eyeSize, 15, 0.1); this.tentaclePhase += 0.1;
    }
    display() {
        push(); translate(this.pos.x, this.pos.y);
        if (gameState === 2) rotate(frameCount * 0.2); else rotate(this.vel.y * 0.02);
        scale(1, this.squish);
        let level = this.evolutionLevel; if (level > 5) level = 5;
        switch(level) {
            case 0: this.drawSquid(); break; case 1: this.drawCuttlefish(); break; case 2: this.drawJellyfish(); break;
            case 3: this.drawSeahorse(); break; case 4: this.drawAnglerfish(); break; case 5: this.drawGoldenSquid(); break;
            default: this.drawSquid();
        }
        if (level >= 5) { noFill(); stroke(255, 215, 0, 100); strokeWeight(2); let aura = 80 + sin(frameCount * 0.2) * 10; ellipse(0, 0, aura, aura); }
        pop();
    }
    drawSquid() {
        noFill(); strokeWeight(4); for(let i=-2; i<=2; i++) { stroke(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 200); beginShape(); for(let j=0; j<8; j++) { let wave = sin(this.tentaclePhase + i + j*0.5) * j*1.5; vertex(i*10 + wave, 30 + j*8); } endShape(); }
        noStroke(); fill(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 150); arc(0, 0, this.size*1.8, this.size*1.8, PI, TWO_PI); rect(-this.size*0.9, 0, this.size*1.8, 10); this.drawEyes(-20, -10);
    }
    drawCuttlefish() {
        noFill(); strokeWeight(4); for(let i=-1; i<=1; i++) { stroke(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 200); line(i*10, 40, i*15, 70); }
        noStroke(); fill(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 150); beginShape(); vertex(0, -50); vertex(30, 0); vertex(0, 50); vertex(-30, 0); endShape(CLOSE); this.drawEyes(-15, -10);
    }
    drawJellyfish() {
        noFill(); strokeWeight(2); for(let i=-3; i<=3; i++) { stroke(255, 100); let wave = sin(this.tentaclePhase + i*0.5 + frameCount*0.1) * 10; line(i*8, 10, i*10 + wave, 60); }
        noStroke(); fill(200, 200, 255, 100); arc(0, 0, 60, 50, PI, TWO_PI); this.drawEyes(-15, -10);
    }
    drawSeahorse() {
        noFill(); stroke(this.bodyColor); strokeWeight(18); beginShape(); vertex(0, -35); bezierVertex(20, -35, 25, -10, 5, 10); bezierVertex(-25, 25, -25, 50, 15, 60); endShape();
        strokeWeight(8); line(0, -30, -25, -25); noStroke(); fill(red(this.bodyColor), green(this.bodyColor), blue(this.bodyColor), 150); triangle(-10, 0, -25, 10, -10, 20); this.drawEyes(5, -25);
    }
    drawAnglerfish() {
        stroke(255); strokeWeight(2); noFill(); beginShape(); vertex(0, -25); bezierVertex(10, -40, 20, -40, 35, -20); endShape(); noStroke(); fill(255, 255, 0); ellipse(35, -20, 15); fill(255, 255, 0, 100); ellipse(35, -20, 30);
        fill(this.bodyColor); ellipse(0, 0, 80, 70); fill(this.bodyColor); arc(0, 20, 70, 40, 0, PI); fill(255); triangle(-20, 25, -15, 45, -10, 25); triangle(10, 25, 15, 45, 20, 25); triangle(0, 25, 5, 40, 10, 25); this.drawEyes(-15, -10);
    }
    drawGoldenSquid() {
        this.drawSquid(); fill(0); noStroke(); rect(-35, -15, 30, 15, 2); rect(5, -15, 30, 15, 2); rect(-5, -10, 10, 3); fill(255, 100); rect(-30, -12, 10, 5); rect(10, -12, 10, 5); fill(255, 215, 0); stroke(255); strokeWeight(2); beginShape(); vertex(-20, -35); vertex(-10, -50); vertex(0, -35); vertex(10, -50); vertex(20, -35); endShape(CLOSE);
    }
    drawEyes(x, y) { fill(255); noStroke(); ellipse(x, y, this.eyeSize+5); ellipse(-x, y, this.eyeSize+5); fill(0); ellipse(x, y + this.vel.y*0.2, 5); ellipse(-x, y + this.vel.y*0.2, 5); }
}

class Bubble {
    constructor(x, y, burst) { this.pos = createVector(x, y); this.isBurst = burst; if(burst) { this.vel = p5.Vector.random2D().mult(random(2, 5)); this.size = random(5, 10); this.alpha = 255; } else { this.vel = createVector(-gameSpeed * random(0.5, 1.5), random(-1, 1)); this.size = random(2, 5); this.alpha = random(50, 150); } }
    update() { this.pos.add(this.vel); if(this.isBurst) { this.size *= 0.9; this.alpha -= 10; } }
    display() { if(this.alpha <= 0) return; noStroke(); fill(200, 255, 255, this.alpha); ellipse(this.pos.x, this.pos.y, this.size); }
    finished() { return this.alpha < 0 || this.pos.x < 0; }
}

class StarParticle {
    constructor(x, y) { this.pos = createVector(x, y); this.vel = p5.Vector.random2D().mult(random(5, 10)); this.acc = createVector(0, 0.2); this.size = random(10, 20); this.alpha = 255; this.rotation = random(TWO_PI); this.rotSpeed = random(-0.2, 0.2); }
    update() { this.vel.add(this.acc); this.pos.add(this.vel); this.alpha -= 5; this.rotation += this.rotSpeed; }
    display() { if(this.alpha <= 0) return; push(); translate(this.pos.x, this.pos.y); rotate(this.rotation); noStroke(); fill(255, 215, 0, this.alpha); beginShape(); for (let i = 0; i < 5; i++) { let angle = TWO_PI * i / 5 - HALF_PI; let x = cos(angle) * this.size; let y = sin(angle) * this.size; vertex(x, y); angle += TWO_PI / 10; let x2 = cos(angle) * (this.size * 0.4); let y2 = sin(angle) * (this.size * 0.4); vertex(x2, y2); } endShape(CLOSE); pop(); }
    finished() { return this.alpha < 0; }
}
</script>
</body>
</html>
